let g=null,n=!1;self.onmessage=async c=>{const{id:o,data:t,cancelable:l}=c.data;if(c.data.type==="cancel"){n=!0;return}try{g=o,n=!1;const s=await u(t,o);if(!n){const r={id:o,result:s,status:"success"};self.postMessage(r)}}catch(s){if(!n){const r={id:o,error:s instanceof Error?s.message:String(s),status:"error"};self.postMessage(r)}}finally{g=null}};async function u(c,o){const{geometryDataArray:t,layerName:l}=c,s=[],r=5;console.log(`Worker: Processing ${t.length} geometries for ${l}`);for(let a=0;a<t.length;a+=r){if(n||g!==o)throw new Error("Processing cancelled");const m=t.slice(a,a+r);for(const e of m){if(!e.hasData||!e.vertices||e.vertices.length===0){console.log(`Worker: Skipping empty geometry data: hasData=${e.hasData}, vertices=${e.vertices?.length||0}`);continue}const i={vertices:e.vertices,normals:e.normals,colors:e.colors,indices:e.indices,uvs:e.uvs,properties:e.properties,hasData:!0,needsNormals:!e.normals};s.push(i)}if(a+r<t.length){const e=(a+r)/t.length;self.postMessage({id:o,status:"progress",progress:e,result:{status:`Processing geometries... (${Math.min(a+r,t.length)}/${t.length})`,progress:e*.8+.1}}),await new Promise(i=>setTimeout(i,1))}}return console.log(`Worker: Created ${s.length} processed geometries for ${l}`),{geometries:s,layerName:l,geometryCount:s.length}}
